# Generics en Go
27 de Septiembre 2023

Agustin Luques
HomeVision
luquesagustin@gmail.com

Nicol치s del Piano
HomeVision
ndel314@gmail.com

## Nosotros

- Software Engineers

.image assets/hv-logo.png 150 _
.caption [[https://homevision.co][HomeVision]]

- Experiencia en Go

.image assets/golang-logo.png 

## Agenda

1. Introducci칩n
1. Sintaxis
1. Type Parameters en **Funciones**
1. Constraints Literals
1. Constraints Package
1. Tilde (`~`)
1. Type Parameters en **Tipos**
1. Type Inference
1. Limitaciones
1. Cu치ndo s칤 y cu치ndo no usar Generics

## Introducci칩n

Los _Generics_ (o _type parameters_) fueron introducidos en Go `v1.18`

**Seguro? 游뱂**

Previo a `v1.18` se podia utilizar `len`, `cap`, `make`.

Tambi칠n los `maps`, `slices` y `channels` aceptaban cualquier tipo

.code presentation.go /^func PrintArrays/,/^}/

## Introducci칩n

Se podia utilizar `interface{}`

.code presentation.go /^func PrintValue/,/^}/

## Introducci칩n

As칤 es como en la `v1.18` deciden darle el mismo poder a los desarrolladores

.image assets/generics.png  _ 600

## Sintaxis

.code presentation.go /START SYNTAX1 OMIT/,/END SYNTAX1 OMIT/

## Sintaxis

.code presentation.go /START SYNTAX2 OMIT/,/END SYNTAX2 OMIT/

## Sintaxis

.code presentation.go /START SYNTAX3 OMIT/,/END SYNTAX3 OMIT/

## Sintaxis

.image assets/pala.png _ 400

Ejercicio 1 - Basic

## Type Parameters en Funciones

**Problemas previo a Generics**

Funciones que hacian escencialmente lo mismo para distintos tipos

Generaba codigo repetido porque termin치bamos copiando y pegando la misma definici칩n para los distintos tipos

.code presentation.go /^func MapStringsToStrings/,/^}/

.code presentation.go /^func MapIntsToInts/,/^}/

## Type Parameters en Funciones

.image assets/pala.png _ 400

Ejercicio 2 - Type Parameters en Funciones

## Constraints Literals

Los tipos genericos no siempre son `any`. 

Se pueden restringir a un conjunto de tipos (o _type sets_)

.code contraints-literals/literals.go /START1 OMIT/,/END1 OMIT/

## Constraints Literals

.code contraints-literals/literals.go /START2 OMIT/,/END2 OMIT/

## Constraints Literals

.code contraints-literals/literals.go /START3 OMIT/,/END3 OMIT/

## Constraints Literals

.code contraints-literals/literals.go /START4 OMIT/,/END4 OMIT/

.image assets/type-sets.png _ 900

## Constraints Package

Definir todos los tipos que aceptamos puede ser medio tedioso

.image assets/lazy-gopher.png _ 710

## Constraints Package

.image assets/pala.png _ 400

Ejercicio 3 - Constraints Package

## Tilde (~)

.image assets/pala.png _ 400

Ejercicio 4 - Tilde (~)

## Type Parameters en Tipos

Hay otro lugar donde vamos a ver par치metros de tipos, y es en definiciones de tipos o interfaces.

```
type Tupla[T any] struct {
  t1 T
  t2 T
}

tupla := Tupla{t1: 1, t2: 2}
```

## Type Parameters in Types

Tambi칠n podemos crear interfaces que contengan par치metros de tipos:

```go
type Sumable[T any] interface {
  fmt.Stringer
  Sumar(T) T
}

type Entero int

func (e Entero) String() string {
  return fmt.Sprintf("%d", e)
}

func (e Entero) Sumar(b Entero) Entero {
  return e + b
}

func Suma[T Sumable[T]](a, b T) T {
	return a.Sumar(b)
}

// Entero satisface la interfaz gen칠rica Sumable
fmt.Println(Suma[Entero](1, 100)) // 101
```

## Type Parameters en Tipos

.image assets/pala.png _ 400

Ejercicio 5 - Generics Types

## Type Inference

Go puede inferir el tipo sin tener que especificarlo

**Partial inference**

.code type-inference/inference.go

## Type Inference Advanced

.image assets/pala.png _ 400

Ejercicio 6 - Type Inference Advanced

## Limitaciones

.code 07-common-struct-fields/common_fields.go 

## Limitaciones

.image assets/github-issue-1.png _ 1000
.image assets/github-issue-2.png _ 1000
.caption [[https://github.com/golang/go/issues/48522][Github Issue]]

## Limitaciones

.image assets/go-1.18-doc.png _ 1000
.caption [[https://go.dev/doc/go1.18][Go v1.18]]

## M치s Limitaciones

Una declaraci칩n de alias de tipo no puede tener un par치metro de tipo:

```go
type T[X, Y any] func(X) Y

type A = T[int, string] // ok

type B[X any] = T[X, X] // error: generic type cannot be alias
```

## M치s Limitaciones

Una declaraci칩n de alias de tipo no puede tener un _type parameters_

```go
type T[X, Y any] func(X) Y

type A = T[int, string] // ok

type B[X any] = T[X, X] // error: generic type cannot be alias
```

## M치s Limitaciones

Actualmente los m칠todos no soportan _type parameters_

```go
type Moneda struct {
  valor int
}

func (m *Moneda) Valor[T ~int]() T {
  return m.valor // syntax error: method must have no type parameters
}
```

.caption [[https://github.com/golang/go/issues/49085][Github Issue]]

## M치s Limitaciones

Los estructuras embebidas no pueden provenir de _type parameters_

```go
type Derived[Base any] struct {
	Base // error: embedded field type cannot be a (pointer to a) type parameter
	x bool
}

## Cu치ndo s칤 y cu치ndo no usar Generics

Funciones de prop칩sito general

.code presentation.go /^func Map\[T1, T2 any\]/,/^}/

.image assets/gopher-ok.png _ 450

## Cu치ndo s칤 y cu치ndo no usar Generics

Estructuras de datos de prop칩sito general

.code presentation.go /START WHEN1 OMIT/,/END WHEN1 OMIT/

.image assets/gopher-ok.png _ 450

## Cu치ndo s칤 y cu치ndo no usar Generics

Cuando no agrega valor, lo hace dif칤cil de leer o menos performante.

O simplemente llamamos a un m칠todo del par치metro

```
func ReadSome(r io.Reader) ([]byte, error) 

func ReadSome[T io.Reader](r T) ([]byte, error) 

```

.image assets/gopher-no.png _ 450

## Cu치ndo s칤 y cu치ndo no usar Generics

Cuando la implementaci칩n var칤a seg칰n el tipo

.code presentation.go /^func GetStringFrom/,/^}/

.image assets/gopher-no.png _ 250
